from collections import Counter

def predict_next_number(history):
    if not history or len(history) < 5:
        return "Not enough data to predict."

    # 1. Frequency Analysis (last 10 numbers)
    recent = history[-10:]
    freq = Counter(recent)
    most_common = freq.most_common()

    # 2. Transition Prediction (last 2 to 3 patterns)
    transitions = {}
    for i in range(len(history) - 1):
        pair = (history[i], history[i + 1])
        transitions[pair] = transitions.get(pair, 0) + 1

    last_number = history[-1]
    likely_next = []

    # Find most frequent number following the last number
    for (a, b), count in transitions.items():
        if a == last_number:
            likely_next.append((b, count))

    likely_next.sort(key=lambda x: -x[1])  # highest count first

    # 3. Combine: Top candidates
    candidates = []
    if likely_next:
        top_likely = likely_next[0][0]
        candidates.append(top_likely)

    if most_common:
        top_common = most_common[0][0]
        if top_common not in candidates:
            candidates.append(top_common)

    # 4. Fallback: Most recent pattern repetition
    if len(set(recent)) <= 3:
        # Only 2â€“3 unique numbers repeating
        candidates.append(recent[-2])  # may repeat again

    # Ensure unique candidates
    final_prediction = list(dict.fromkeys(candidates))[:3]

    return {
        "predicted_number": final_prediction[0],
        "confidence": "high" if len(final_prediction) == 1 else "medium",
        "top_3_predictions": final_prediction
    }

# Example usage
past_results = [3, 4, 7, 2, 2, 5, 2, 7, 3, 2, 7, 3, 2]
result = predict_next_number(past_results)

print("ðŸ”® Prediction Result:")
print("âž¡ï¸ Likely next number:", result['predicted_number'])
print("ðŸ“Š Top 3 candidates:", result['top_3_predictions'])
print("ðŸ”’ Confidence level:", result['confidence'])
